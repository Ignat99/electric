<!-- HEADER 8-10: Technology XML File Format -->

<H4>Introduction</H4>

Layout technologies in Electric can be described by Xml technology files.
These files are automatically generated by the technology editor and the technology-creation wizard,
but some users may prefer to edit them by hand.
For these users, the following is a description of the technology XML file format.
<P>
Electric currently has Xml technology files that are unparameterized
(all values are explicitly entered and there is no symbolic information).
Technology distances are specified as double-precision numbers in display units.
Future versions of Electric may implement a symbolic style of Xml technology files.
<P>
Currently technology files contain two kinds of information:
<OL>
<LI>Electric-independent information.
This includes physical and electrical details of the foundry process.
Most of these details are attached to Layers and includes
design rules, simulation information, etc.</LI>
<LI>Electric-specific information.
This includes the primitive nodes and arcs that Electric uses for design.
It also has connectivity rules, display and print styles,
component menus for the technology, etc.</LI>
</OL>
<P>
Primitive nodes and arcs can be considered to be layout macros.
Node description consists of a set of two-dimensional shapes.
Arcs description consists of a set of one-dimensional intervals, which are stretched in the other dimension.
The technology file describes primitive nodes and arcs of a standard size (usually
the DRC minimum) and also includes information about how they can grow larger.
Instances of these nodes and arcs in Libraries can be larger than standard.
<P>
A primitive node or arc can consists of many shapes in different technology Layers.
Each shape in a primitive node is called a <B>NodeLayer</B>.
Each interval in a primitive arc is called an <B>ArcLayer</B>.
<P>
The minimum bounding box of all NodeLayers of a primitive node is called its <B>FullRectangle</B>.
Description of a primitive node can also define the FullRectangle explicitly.
The largest of all ArcLayers in a primitive arc defines its <B>FullWidth</B>.
<P>
Primitive nodes and arcs also have the notion of a <B>BaseRectangle</B> and a <B>BaseWidth</B>.
They relate to the shape of the most important layer in this node or arc.
The BaseRectangle of a primitive node is described explicitly.
The BaseWidth of primitive arc is the width of the first 'ArcLayer' in the arc description.
The BaseRectangle and BaseWidth are highlighted in the Edit Window and they appear
in Properties dialogs.
<P>
Instances of nodes and arcs in a library can have sizes larger than standard.
Electric writes size information of each instance in the library files.
Since release 8.05 of Electric (or more precisely since the 8.05o development version)
library files contain the extent of the node/arc over its standard size
described in the technology file.  When you switch a design library from one technology
to another compatible technology, the standard size node/arc in old technology is
converted to the standard size node/arc in the new technology. The node/arc which extends
by 1 unit beyond the standard node/arc in old technology is converted to a node/arc which
extends by 1 unit beyond the standard node/arc in new technology.
<P>
Older Electric releases wrote sizes of node/arc instances in another way.
Jelib format before Electric 8.05 (actually, the 8.05g development version) and all Elib files
saved the size of the FullRectangle and FullWidth.
Jelib format between 8.05g and 8.05n wrote sizes of BaseRectangle and BaseWidth.
The Full and Base sizes can be redefined in future versions of technology file.
To be able to read older Jelib formats correctly after redefinition of Full and Base,
Technology file can contain explicit sizes of standard nodes and arcs in older library files.
<P>
All sizes in technology files are in display units.
There is a scale declaration which relates this unit to nanometers.
<P>
<H4>Overall Structure</H4>
<P>
Here is a description of Xml technology file in Electric releases 8.05 and 8.06.
<P>
<B>&lt;technology&gt;</B> is the main element of the Xml technology file. It has many Xml-specific attributes:
<UL>
<LI>
    <B>"name"</B> contains the name of this technology inside Electric.
</LI>
<LI>
    <B>"class"</B> (optional) contains the name of a Java class which is a subclass of "com.sun.electric.technology.Technology".
	It can be used to describe things which are not described by the Xml technology class yet.
	The interface with this class is not specified and can be changed.
	If you need a non-standard technology feature, the better way is to contact Electric developers about this.
</LI>
</UL>
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;technology name="mocmos"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class="com.sun.electric.technology.technologies.MoCMOS"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns="http://electric.sun.com/Technology"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xsi:schemaLocation="http://electric.sun.com/Technology<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;../../technology/Technology.xsd"&gt;</FONT></CODE>
<P>
Inside of the &lt;technology&gt; element are these subelements:
<UL>
<LI>
    <B>&lt;shortName&gt;</B> a more descriptive name for the technology (optional)
</LI>
<LI>
    <B>&lt;description&gt;</B> the most descriptive name for the technology.
</LI>
<LI>
    <B>&lt;version&gt;</B> describes Electric versions when Jelib changed and how it affects sizes.
	The "tech" attribute contains an identifier of this version used in subsequent &lt;diskOffset&gt; subelements
	of &lt;arcProto&gt; and &lt;primitiveNode&gt; descriptions. The "electric" attribute is a corresponding Electric version.
	These elements are usually fixed in all technology files.<BR>
	Examples:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;version tech="1" electric="8.05g"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;version tech="2" electric="8.05o"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;numMetals&gt;</B> describes a possible range for the number of metall layers in the technology.
	There is no good support for Xml technology files with a variable number of metal layers.
	Therefore, this element should contains the same value for all three attributes.<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;numMetals min="6" max="6" default="6"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;scale&gt;</B> defines how many nanometers are in a display unit.
	Electric uses dimensionless "units" in its interface, where a transistor may be "2x3"
	without specifying actual distances.  This scale converts the units to real spacings.
	The "relevant" attribute should be true for layout technologies.<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;scale value="200.0" relevant="true"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;resolution&gt;</B> defines the minimum resolution value in grid units used in DRC,
	a parameter to determine which points are off-grid.<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;resolution value="2.0"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;defaultFoundry&gt;</B> is a name of the default foundry for this technology.
	The name references one of the &lt;foundry&gt; elements found later in the Xml file.<BR>
	Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;defaultFoundry value="MOSIS"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;minResistance&gt;</B> global minimum resistance (for parasitics).<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;minResistance value="4.0"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;minCapacitance&gt;</B> global minimum capacitance (for parasitics).<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;minCapacitance value="0.1"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;logicalEffort&gt;</B> defines default project preferences for the Logical Effort tool.<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;logicalEffort gateCapacitance="0.167" wireRatio="0.16"<BR>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diffAlpha="0.7"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;transparentLayer&gt;</B> defines the transparent layers in the technology.  All layers can be drawn
	in either a "transparent" or "opaque" style.  Transparent layers can overlap other transparent
	layers without obscuring each other (they blend where they overlap).  Opaque layers cover all
	other layers without blending.  Because the system needs to store all combination of transparent
	layers, it is not possible to make every layer transparent.  Instead, less-used layers should
	be opaque and use a stipple-pattern so that they do not cover everything.
        The exception is the <I>Layer-Display Algorithm</I> which does not use the transparent/opaque distinction
        (see <A HREF="chap04-03.html#chap04-03">Section 4-3</A> for more on the display algorithms).
	This element lists the number of transparent layers, and provides the color of each.  The system
	automatically determines the blending colors where multiple transparent layers overlap.<BR>
	Example:<BR>
	<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;transparentLayer transparent="1"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;r&gt;96&lt;/r&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;g&gt;209&lt;/g&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;b&gt;255&lt;/b&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/transparentLayer&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;layer&gt;</B> a list of layer descriptions (see below).
</LI>
<LI>
    <B>&lt;arcProto&gt;</B> a list of primitive arc descriptions (see below).
</LI>
<LI>
    <B>&lt;primitiveNode/primitiveNodeGroup&gt;</B> a list of primitive node and primitive node group descriptions (see below).
</LI>
<LI>
    <B>&lt;spiceHeader&gt;</B> default spice models.
</LI>
<LI>
    <B>&lt;menuPalette&gt;</B> description of the default component menu (optional).
</LI>
<LI>
    <B>&lt;foundry&gt;</B> information for the Foundry. Each has default DRC rules and default GDS mapping.
</LI>
</UL>

<H4>Layers</H4>
<P>
The &lt;layer&gt; elements define layers in the technology.  They contains these attributes:
<UL>
<LI>
    <B>"name"</B> the name of this layer. Layer names are not referenced in Library files.
    They are used only in the description of primtive nodes and arcs and in DRC rules.
</LI>
<LI>
    <B>"fun"</B> the function of this layer, taken from this list:
	<BR>&nbsp;&nbsp;&nbsp;UNKNOWN
	<BR>&nbsp;&nbsp;&nbsp;METAL1 ... METAL12 <I>(metal)</I>
	<BR>&nbsp;&nbsp;&nbsp;METAL1C1 ... METAL12C1 <I>(metal)</I>
	<BR>&nbsp;&nbsp;&nbsp;METAL1C2 ... METAL12C2 <I>(metal)</I>
	<BR>&nbsp;&nbsp;&nbsp;METAL1C3 ... METAL12C3 <I>(metal)</I>
	<BR>&nbsp;&nbsp;&nbsp;POLY1 ... POLY3 <I>(polysilicon)</I>
	<BR>&nbsp;&nbsp;&nbsp;GATE <I>(gate polysilicon)</I>
	<BR>&nbsp;&nbsp;&nbsp;DIFF DIFFP DIFFN <I>(active)</I>
	<BR>&nbsp;&nbsp;&nbsp;IMPLANT IMPLANTP IMPLANTN SUBSTRATE WELL WELLP WELLN <I>(implants)</I>
	<BR>&nbsp;&nbsp;&nbsp;CONTACT1 ... CONTACT12 <I>(cuts)</I>
	<BR>&nbsp;&nbsp;&nbsp;RESISTOR CAP <I>(resistor/capacitor)</I>
	<BR>&nbsp;&nbsp;&nbsp;TRANSISTOR <I>(transistor)</I>
	<BR>&nbsp;&nbsp;&nbsp;EMITTER BASE COLLECTOR <I>(bipolar parts)</I>
	<BR>&nbsp;&nbsp;&nbsp;DMY* DEXCL* <I>(dummy and dummy-exclusion for different layers)</I>
	<BR>&nbsp;&nbsp;&nbsp;BUS ART <I>(schematics and artwork)</I>
	<BR>&nbsp;&nbsp;&nbsp;PLUG OVERGLASS GUARD ISOLATION <I>(specialty)</I>
	<BR>&nbsp;&nbsp;&nbsp;TILENOT CONTROL <I>(specialty)</I>
</LI>
<LI>
    <B>"extraFun"</B> optional functions for this layer, taken from this list:
	<BR>&nbsp;&nbsp;&nbsp;nonelectrical
	<BR>&nbsp;&nbsp;&nbsp;connects-metal connects-poly connects-diff
	<BR>&nbsp;&nbsp;&nbsp;heavy light depletion_heavy depletion_light enhancement_heavy enhancement_light
	<BR>&nbsp;&nbsp;&nbsp;vt thick native
	<BR>&nbsp;&nbsp;&nbsp;inside_transistor deep carb-nano
	<BR>&nbsp;&nbsp;&nbsp;n-type <I>deprecated: use fun=IMPLANTN</i>
	<BR>&nbsp;&nbsp;&nbsp;p-type <I>deprecated: use fun=IMPLANTP</i>
</LI>
</UL>
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;layer name="Poly-Cut" fun="CONTACT1" extraFun="connects-poly"&gt;</FONT></CODE>
<P>
Inside of the &lt;layer&gt; element are these subelements:
<UL>
<LI>
    <B>&lt;transparentColor&gt;</B> the transparent color to use (if omitted, this is an opaque layer).
</LI>
<LI>
    <B>&lt;opaqueColor&gt;</B> the opaque color to use.
</LI>
<LI>
    <B>&lt;patternedOnDisplay&gt;</B> true to use the &lt;pattern&gt; when drawing on the screen.
</LI>
<LI>
    <B>&lt;patternedOnPrinter&gt;</B> true to use the &lt;pattern&gt; when printing.
</LI>
<LI>
    <B>&lt;pattern&gt;</B> the stipple pattern to use (if requested on either the screen or printed page).
</LI>
<LI>
    <B>&lt;outlined&gt;</B> true to outline the layer (sensible only for patterned layers).
</LI>
<LI>
    <B>&lt;opacity&gt;</B> intensity of this layer (from 0 to 1).
</LI>
<LI>
    <B>&lt;foreground&gt;</B> true to place this layer in the foreground.
</LI>
<LI>
    <B>&lt;display3D&gt;</B> defines thickness and height above the substrate for 3D display and parasitics.
    The element has these attributes:
    <UL>
    <LI>
        <B>"thick"</B> 3D thickness of the layer in display units
    </LI>
    <LI>
        <B>"height"</B> 3D height of the bottom of the layer in display units
    </LI>
    <LI>
        <B>"mode"</B> 3D display style
    </LI>
    <LI>
        <B>"factor"</B> 3D display style
    </LI>
    </UL>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;display3D thick="0.75" height="15.75" mode="NONE" factor="0.2"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;cifLayer&gt;</B> CIF layer name.
</LI>
<LI>
    <B>&lt;skillLayer&gt;</B> Skill layer name.
</LI>
<LI>
    <B>&lt;parasitics&gt;</B> parasitic extractor subelements.
</LI>
<LI>
    <B>&lt;pureLayerNode&gt;</B> description of the pure-layer node for this layer.
    This node is used to represent arbitrary polygons of this Layer.
    It is also used when importing from external formats like GDS.
    The standard pure-layer node has zero FullRectangle and BaseRectangle.
    So library files contain exact geometric information for instances of pure-layer node.
    All the shape of pure-layer node is considered a port shape of the single port of the node.
    There are these optional subelements:
    <UL>
    <LI>
         <B>&lt;oldName&gt;</B> if the pure-layer node has another name in older versions of the technology.
    </LI>
    <LI>
         <B>&lt;lambda&gt;</B> the default width of this pure-layer-node (in grid units) when it is placed manually.
    </LI>
    <LI>
         <B>&lt;portArc&gt;</B> the list of arc names which can connect to this pure-layer node.
    </LI>
    </UL>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;pureLayerNode name="Transistor-Poly-Node" port="trans-poly-1"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambda&gt;2.0&lt;/lambda&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portArc&gt;Polysilicon-1&lt;/portArc&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/pureLayerNode&gt;</FONT></CODE>
</LI>
</UL>

<!-- NEED 5in -->
<H4>Arcs</H4>
<P>
&lt;arcProto&gt; elements describe primitive arcs in the technology.  They have these attributes:
<UL>
<LI>
    <B>"name"</B> is the name of the arc prototype.
    The instances of the primitive arc in Electric libraries reference this name.
</LI>
<LI>
    <B>"fun"</B> describes the arc function:
    <BR>&nbsp;&nbsp;&nbsp;UNKNOWN
    <BR>&nbsp;&nbsp;&nbsp;METAL1 ... METAL12 <I>(metal)</I>
    <BR>&nbsp;&nbsp;&nbsp;POLY1 ... POLY3 <I>(polysilicon)</I>
    <BR>&nbsp;&nbsp;&nbsp;DIFF DIFFP DIFFN DIFFS DIFFW <I>(active)</I>
    <BR>&nbsp;&nbsp;&nbsp;BUS <I>(busses)</I>
    <BR>&nbsp;&nbsp;&nbsp;UNROUTED <I>(unrouted, for routers)</I>
    <BR>&nbsp;&nbsp;&nbsp;NONELEC <I>(non-electrical, for constraints)</I>
</LI>
</UL>
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;arcProto name="P-Active" fun="DIFFP"&gt;</FONT></CODE>
<P>
Inside of the &lt;arcProto&gt; element are these subelements:
<UL>
<LI>
    <B>&lt;oldName&gt;</B> the name of this primitive arc in previous versions of the technology (optional).
</LI>
<LI>
    <B>&lt;wipable&gt;</B> flag to mark that the arc erases its pins. This flag is usually present in layout technologies.
</LI>
<LI>
    <B>&lt;curvable&gt;</B> flag to described round arcs. It is not supported in the current implementation.
</LI>
<LI>
    <B>&lt;special&gt;</B> flag related to the component menu.
</LI>
<LI>
    <B>&lt;skipSizeInPalette&gt;</B> flag related to the component menu.
</LI>
<LI>
    <B>&lt;notUsed&gt;</B> flag to forbid use of this primitive arc in libraries.
</LI>
<LI>
    <B>&lt;extended&gt;</B> default state of end-extension for this arc.
</LI>
<LI>
    <B>&lt;fixedAngle&gt;</B> default state of the fixed-angle constraint on this arc.
</LI>
<LI>
    <B>&lt;angleIncrement&gt;</B> default state of the angle-increment amount on this arc (grids placement angles).
</LI>
<LI>
    <B>&lt;antennaRatio&gt;</B> value used by the ERC tool.
</LI>
<LI>
    <B>&lt;diskOffset&gt;</B> tells how sizes were written in older library files.
    The attribute "untilVersion" references the "tech" attribute of the &lt;version&gt; element above.
    This disk offset is applied to Jelib libraries with Electric versions prior to the "electric" attribute
    of that &lt;version&gt; element.  Attribute &lt;width&gt; is actually half of the value written to Jelib file.
    For example, the "P-Active" arc described above will be:<BR>
    &nbsp;&nbsp;&nbsp;15.0 wide with Jelib prior to Electric version "8.05g";<BR>
    &nbsp;&nbsp;&nbsp;3.0 wide with Jelib prior to Electric version "8.05o";<BR>
    &nbsp;&nbsp;&nbsp;0.0 wide with Jelib in Electric versions since "8.05o".<BR>
    More formally, let <I>a.extend</I> be the internal value associated with the arc instance in the Electric database.
    The value written to libraries prior to "diskOffset.untilVersion" was <I>2*(a.extend + diskOffset.width)</I>.
    The &lt;diskOffset&gt; element is necessary only in legacy technologies.<BR>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;diskOffset untilVersion="1" width="7.5"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;defaultWidth&gt;</B> factory default value of arc width. This element is not used now and should be omitted.
</LI>
<LI>
    <B>&lt;arcLayer&gt;</B> a list of ArcLayers that comprise this Arc.
    The attribute "layer" references the layer of the ArcLayer.
    The attribute "style" is either "FILLED" or "CLOSED". Layout arcs should be "FILLED".
    The &lt;lambda&gt; subelement describes extent (half width) of the ArcLayer from the central line of the arc.<BR>
    More formally, let <I>a.extend</I> be the internal value associated with the arc instance in the Electric database.
    The width of the "P-Select" &lt;arcLayer&gt; below is <I>2*(a.extend + 3.5)</I>
    The FullWidth of the arc instance is the width of the widest ArcLayer.
    It is <I>2*(a.extend + 7.5)</I> in the above "P-Active" arc.
    The BaseWidth of the arc instance is the width of the first ArcLayer in the list.
    It is <I>2*(a.extennd + 1.5)</I> in the above "P-Active" arc.<BR>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;arcLayer layer="P-Select" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambda&gt;3.5&lt;/lambda&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/arcLayer&gt;</FONT></CODE>
</LI>
</UL>
<P>
Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;arcProto name="P-Active" fun="DIFFP"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;wipable/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;extended&gt;true&lt;/extended&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;fixedAngle&gt;true&lt;/fixedAngle&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;angleIncrement&gt;90&lt;/angleIncrement&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;antennaRatio&gt;200.0&lt;/antennaRatio&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;diskOffset untilVersion="1" width="7.5"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;diskOffset untilVersion="2" width="1.5"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;arcLayer layer="P-Active" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambda&gt;1.5&lt;/lambda&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/arcLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;arcLayer layer="N-Well" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambda&gt;7.5&lt;/lambda&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/arcLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;arcLayer layer="P-Select" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambda&gt;3.5&lt;/lambda&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/arcLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/arcProto&gt;</FONT></CODE>

<P>
<!-- NEED 4in -->
<H4>Nodes</H4>
<P>
&lt;primitiveNode&gt; elements describe primitive node in the technology.  They have these attributes:
<UL>
<LI>
    <B>"name"</B> is the name of the node prototype.
    Instances of this primitive node in Electric libraries reference this name.
</LI>
<LI>
    <B>"fun"</B> describes the node function:
    <BR>&nbsp;&nbsp;&nbsp;UNKNOWN
    <BR>&nbsp;&nbsp;&nbsp;PIN <I>(pins connect arcs)</I>
    <BR>&nbsp;&nbsp;&nbsp;NODE <I>(pure layer nodes)</I>
    <BR>&nbsp;&nbsp;&nbsp;CONTACT CONNECT <I>(nodes that connect all arcs)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRANMOS TRAPMOS TRA4NMOS TRA4PMOS <I>(CMOS transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRADMOS TRA4DMOS <I>(nMOS transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRANPN TRAPNP TRA4NPN TRA4PNP <I>(Bipolar transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRANJFET TRAPJFET TRA4NJFET TRA4PJFET <I>(JFET transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRADMES TRAEMES TRA4DMES TRA4EMES <I>(MESFET transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRANS TRANS4 <I>(generic transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;TRANSREF <I>(reference transistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;RESIST PRESIST WRESIST ESDDEVICE <I>(resistors)</I>
    <BR>&nbsp;&nbsp;&nbsp;CAPAC ECAPAC <I>(capacitors)</I>
    <BR>&nbsp;&nbsp;&nbsp;DIODE DIODEZ <I>(diodes)</I>
    <BR>&nbsp;&nbsp;&nbsp;INDUCT <I>(inductors)</I>
    <BR>&nbsp;&nbsp;&nbsp;METER <I>(meters)</I>
    <BR>&nbsp;&nbsp;&nbsp;BASE EMIT COLLECT <I>(Bipolar transistor parts)</I>
    <BR>&nbsp;&nbsp;&nbsp;BUFFER GATEAND GATEOR GATEXOR <I>(logic gates)</I>
    <BR>&nbsp;&nbsp;&nbsp;FLIPFLOPRSMS FLIPFLOPRSP FLIPFLOPRSN <I>(RS flipflops)</I>
    <BR>&nbsp;&nbsp;&nbsp;FLIPFLOPJKMS FLIPFLOPJKP FLIPFLOPJKN <I>(JK flipflops)</I>
    <BR>&nbsp;&nbsp;&nbsp;FLIPFLOPDMS FLIPFLOPDP FLIPFLOPDN <I>(D flipflops)</I>
    <BR>&nbsp;&nbsp;&nbsp;FLIPFLOPTMS FLIPFLOPTP FLIPFLOPTN <I>(T flipflops)</I>
    <BR>&nbsp;&nbsp;&nbsp;MUX <I>(multiplexors)</I>
    <BR>&nbsp;&nbsp;&nbsp;CCVS CCCS VCVS VCCS TLINE <I>(two-port gates)</I>
    <BR>&nbsp;&nbsp;&nbsp;CONPOWER CONGROUND SOURCE <I>(power/ground)</I>
    <BR>&nbsp;&nbsp;&nbsp;SUBSTRATE WELL <I>(implants)</I>
    <BR>&nbsp;&nbsp;&nbsp;ART <I>(artwork)</I>
    <BR>&nbsp;&nbsp;&nbsp;ARRAY <I>(array nodes)</I>
    <BR>&nbsp;&nbsp;&nbsp;ALIGN <I>(alignment nodes)</I>
</LI>
</UL>
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;primitiveNode name="Metal-1-Metal-2-Con" fun="CONTACT"&gt;</FONT></CODE>
<P>
Inside of the &lt;primitiveNode&gt; element are these subelements:
<UL>
<LI>
    <B>&lt;oldName&gt;</B> optional name of this primitive node in previous versions of the technology.
</LI>
<LI>
    <B>&lt;shrinkArcs&gt;</B> flag to shrink arcs connected to the node.  This flag should be "on" only for PIN nodes.
</LI>
<LI>
    <B>&lt;square&gt;</B> flag to restrict the node to be square. It is used in round layout technologies.
</LI>
<LI>
    <B>&lt;canBeZeroSize&gt;</B> flag to allow the size to become zero (not used in layout technologies).
</LI>
<LI>
    <B>&lt;wipes&gt;</B> flag which is not used in layout technologies.
</LI>
<LI>
    <B>&lt;lockable&gt;</B> flag which is used in arrayed technologies (like FPGA).
</LI>
<LI>
    <B>&lt;edgeSelect&gt;</B> flag which is not used in layout technologies.
</LI>
<LI>
    <B>&lt;skipSizeInPalette&gt;</B> flag related to the component menu.
</LI>
<LI>
    <B>&lt;notUsed&gt;</B> flag to forbid use of this primtive node in libraries.
</LI>
<LI>
    <B>&lt;lowVt&gt;</B> flag to mark a low vt transistor.
</LI>
<LI>
    <B>&lt;highVt&gt;</B> flag to mark a high vt transistor.
</LI>
<LI>
    <B>&lt;nativeBit&gt;</B> flag to mark a native transistor.
</LI>
<LI>
    <B>&lt;od18&gt;</B> flag to mark an od18 transistor.
</LI>
<LI>
    <B>&lt;od25&gt;</B> flag to mark an od25 transistor.
</LI>
<LI>
    <B>&lt;od33&gt;</B> flag to mark an od33 transistor.
</LI>
<LI>
    <B>&lt;diskOffset&gt;</B> tells how sizes were written in older library files.  It has this attribute:<BR>
    "untilVersion" references the "tech" attribute of &lt;version&gt; elements above.
    This disk offset is applied to Jelib libraries with Electric version prior to "electric" attribute
    of that &lt;version&gt; element. Attributes &lt;x&gt; and &lt;y&gt; are actually half of the values written to Jelib file.
    So the "Metal-1-Metal-2-Con" node example shown below will be written:<BR>
    &nbsp;&nbsp;&nbsp;5.0 width/height with Jelib prior to Electric version "8.05g";<BR>
    &nbsp;&nbsp;&nbsp;4.0 width/height with Jelib prior to Electric version "8.05o";<BR>
    &nbsp;&nbsp;&nbsp;0.0 width/height with Jelib in Electric versions since "8.05o".<BR>
    More formally, let <I>n.extendX</I> and <I>n.extendY</I> be the internal values associated with the node instance in the Electric database.
    The values written to library prior to "diskOffset.untilVersion" were<BR>
    &nbsp;&nbsp;&nbsp;<I>2*(n.extendX + diskOffset.x)</I> and <I>2*(n.extendY + diskOffset.y)</I>.<BR>
    The &lt;diskOffset&gt; element is necessary only with legacy technologies.<BR>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;diskOffset untilVersion="1" x="2.5" y="2.5"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;defaultWidth&gt;</B> and <B>&lt;defaultHeight&gt;</B> factory default values of the node size.
    The subelement &lt;lambda&gt; contains the value of extendX/extendY in display units.
    Usually these elements are omitted because the default values of extendX and extendY are 0.
    So, the factory defaults of extendX and extendY are defaultWidth.lambda and defaultHeight.lambda
    The factory defaults of BaseWidth and BaseHeight are<BR>
    &nbsp;&nbsp;&nbsp;<I>BaseRectangle.width + 2*defaultWidth.lambda</I><BR>
    and<BR>
    &nbsp;&nbsp;&nbsp;<I>BaseRectangle.height + 2*defaultHeight.lambda</I> .<BR>
    The factory defaults of FullWidth and FullHeight are<BR>
    &nbsp;&nbsp;&nbsp;<I>FullRectangle.width + 2*defaultWidth.lambda</I><BR>
    and<BR>
    &nbsp;&nbsp;&nbsp;<I>FullRectangle.height + 2*defaultHeight.lambda</I> .
</LI>
<LI>
    <B>&lt;nodeBase&gt;</B> defines the BaseRectangle of the node.
    It has a subelement &lt;box&gt; which has in it a subelement &lt;lambdaBox&gt;.
    In the &lt;lambdaBox&gt;, the attributes "klx", "khx", "kly", and "khy" are the coordinates
    of the base rectangle of a standard-size node.
</LI>
<LI>
    <B>&lt;sizeOffset&gt;</B> is deprecated.
</LI>
<LI>
    <B>&lt;protection&gt;</B> defines the protection frame of the cell.
</LI>
<LI>
    <B>&lt;nodeLayer&gt;</B> a list of NodeLayers (described below).
</LI>
<LI>
    <B>&lt;primitivePort&gt;</B> a list of primitive ports on the node.
    The "name" attribute describes the port name.
    To make a library conversion from one technology to another it would help
    to unify port names in some manner.
    Port names of single-port nodes are not very important because the library reader
    can unambiguously connect arcs to the renamed port.
    However, port names of transistors could have compatible names like
    "poly-top", "poly-bottom", "diff-left", "diff-right".
    &lt;primtivePort&gt; has these subelements:
    <UL>
    <LI>
        <B>&lt;portAngle&gt;</B> can restrict direction of arcs which can connect to this port
    </LI>
    <LI>
        <B>&lt;portTopology&gt;</B> is a small integer that is unique among PrimitivePorts on the PrimitiveNode.
        When two PrimitivePorts have the same topology number, it indicates that these ports are connected.
    </LI>
    <LI>
        <B>&lt;box&gt;</B> a rectangle which constraints the position of end point of connected arc
    </LI>
    <LI>
        <B>&lt;portArc&gt;</B> a list of primitive arcs from this technology which can connect to this port
    </LI>
    </UL>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;primitivePort name="metal-1-metal-2"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portAngle primary="0" range="180"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portTopology&gt;0&lt;/portTopology&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-1.0" khx="1.0" kly="-1.0" khy="1.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portArc&gt;Metal-1&lt;/portArc&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portArc&gt;Metal-2&lt;/portArc&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/primitivePort&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;serpTrans&gt;</B> marks this node as serpentine transistor. It supplies 6 special values.
</LI>
<LI>
    <B>&lt;polygonal&gt;</B> marks that this node can be an arbitrary polygon. Usually is not used in layout technologies.
</LI>
<LI>
    <B>&lt;minSizeRule&gt;</B> overrides the FullRectangle of the node and supplies the name of a minimal size rule
    The attributes "width" and "height" describe the size of the FullRectangle.
    The attribute "rule" is the name of minimal size rule. 
    By default the FullRectangle is calculated as the minimum bounding box of all points found in the NodeLayers of a standard primitive node.
    For the "Metal-1-Metal-2-Con" node example shown below, the FullRectangle is calculated as a box with endpoints<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = -2.0, y = -2.0]</I> and <I>[x = 2.0, y = 2.0]</I>.<BR>
    The FullBox of a node instance with n.extendX and n.extendY is:<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = FullRectangle.minX - n.extendX, y = FullRectangle.minY - n.extendY]</I><BR>
    and<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = FullRectangle.maxX + n.extendX, y = FullRectangle.maxY + n.extendY]</I><BR>
    This may be not accurate if shapes which made the minimum bounding box of the standard-size node grows more slowly than
    other shapes when extents are increased.
    The &lt;minSizeRule&gt; element defines the FullRectangle manually as a rectangle with its center at the origin.
    The FullRectangle in the presence of &lt;minSizeRule&gt; is<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = -0.5*minSizeRule.width, y = -0.5*minSizeRule.height]</I><BR>
    and<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = +0.5*minSizeRule.width, y = +0.5*minSizeRule.height]</I><BR>
    This element defines FullRectangle of the "Metal-1-Metal-2-Con" as<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = -2.5, y = -2.5]</I> and <I>[x = 2.5, y = 2.5]</I><BR>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;minSizeRule width="5.0" height="5.0" rule="8.3, 9.3"/&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;spiceTemplate&gt;</B> optional spice template of this node.
</LI>
</UL>
Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;primitiveNode name="Metal-1-Metal-2-Con" fun="CONTACT"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;diskOffset untilVersion="1" x="2.5" y="2.5"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;diskOffset untilVersion="2" x="2.0" y="2.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;sizeOffset lx="0.5" hx="0.5" ly="0.5" hy="0.5"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Metal-1" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-2.0" khx="2.0" kly="-2.0" khy="2.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Metal-2" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-2.0" khx="2.0" kly="-2.0" khy="2.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Via1" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;multicutbox sizex="2.0" sizey="2.0" sep1d="3.0" sep2d="3.0"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="0.0" khx="0.0" kly="0.0" khy="0.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/multicutbox&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;primitivePort name="metal-1-metal-2"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portAngle primary="0" range="180"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portTopology&gt;0&lt;/portTopology&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-1.0" khx="1.0" kly="-1.0" khy="1.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portArc&gt;Metal-1&lt;/portArc&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portArc&gt;Metal-2&lt;/portArc&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/primitivePort&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;minSizeRule width="5.0" height="5.0" rule="8.3, 9.3"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/primitiveNode&gt;</FONT></CODE>
<P>
<H4>Node Layers</H4>
<P>
&lt;nodeLayer&gt; elements describe NodeLayers in the primitive nodes.  They have these attributes:
<UL>
<LI>
    <B>"layer"</B> references the layer of the NodeLayer.
</LI>
<LI>
    <B>"style"</B> is either "FILLED", "CLOSED" or "CROSSED".
    Layout nodes should be "FILLED".  "CROSSED" is used only with pins.
</LI>
<LI>
    <B>"portNum"</B> relates a primitive port to this NodeLayer. It is the 0-based index
    of the &lt;primitivePort&gt; subelement of &lt;primitiveNodeElement&gt;. 
    It does <i>not</i> correspond to the "portTopology" attribute of the associated NodeLayer.
    If you find that auto-stitch behaves strangely, it is possible that you have set this attribute incorrectly.
    Negative values mean that this NodeLayer
    is not related to any port.
    If this attribute is omitted, the first primitive port in the list is chosen. 
</LI>
<LI>
    <B>"electrical"</B> marks this NodeLayer be used only in either electrical or non-electrical node layers.
    For example a transistor's Polysilicon is defined with electrical layers as a gate-poly and two poly-ends.
    The same transistor's Polysilicon is defined with one long stripe in non-electrical layers.
    If this attribute is omitted, the NodeLayer appears in both electrical and non-electrical lists.
    This feature may be removed in future Electric versions.
    So the recommended style is to define NodeLayers of a transistor in electrical style and
    to omit "electrical" attribute in NodeLayers.
</LI>
</UL>
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Metal-2" style="FILLED"&gt;</FONT></CODE>
<P>
<!-- NEED 2in -->
Inside of the &lt;nodeLayer&gt; element are these subelements:
<UL>
<LI>
    <B>&lt;box&gt;</B> defines a rectangular shape.  It has attributes "klx", "khx", "kly", and "khy".
    If these attributes are omitted, their default values are "klx=-1", "khx=1" "kly=-1" "khy=1".
    There is also a subelement &lt;lambdaBox&gt; which has attributes "klx", "khx", "kly", and "khy".
    Attributes of a &lt;lambdaBox&gt; describe the shape of the NodeLayer on a standard size node.
    Attributes of a &lt;box&gt; describe how this shape grows when the node instance is larger than standard.
    In other words, the &lt;box&gt; values are multiplied by the node size (and divided by two) and then the &lt;lambdaBox&gt; values are added to get the coordinates.
    More formally, let <I>n.extendX</I> and <I>n.extendY</I> be the internal values associated with the node instance in the Electric database.
    The shape of the &lt;nodeLayer&gt; with &lt;box&gt; shape is a rectangle with endPoints:<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = lambdaBox.klx + n.extendX*box.klx, y = lambdaBox.kly + n.extendY*box.kly]</I><BR>
    and <BR>
    &nbsp;&nbsp;&nbsp;<I>[x = lambdaBox.khx + n.extendX*box.khx, y = lambdaBox.khy + n.extendY*box.khy]</I><BR>
    For example, the shape of the "Metal-2" NodeLayer below is a rectangle with endPoints:<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = -2 - n.extendX, y = -2 - n.extendY]</I> and <I>[x = 2 + n.extendX, y = 2 + n.extendY]</I><BR>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Metal-2" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-2.0" khx="2.0" kly="-2.0" khy="2.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;points&gt;</B> is followed by &lt;techPoint&gt; elements which describe vertices of a polygon.
    &lt;techPoint&gt; elements have attributes "xm", "xa", "ym", and "ya" which define a point:<BR>
    &nbsp;&nbsp;&nbsp;<I>[x = techPoint.xa + 2*n.extendX*techPoint.xm, y = techPoint.ya + 2*n.extendY*techPoint.ym]</I><BR>
    Notice that meaning of techPoint.xm and techPoint.ym is inconsistent with meanding of box.klx, box.khx, box.kly, box.khy .
</LI>
<LI>
    <B>&lt;multicutbox&gt;</B> a rectangular region where centers of contact-cuts are placed in a uniformly spaced array.
    This is similar to &lt;box&gt;, but it has additional attributes:
    <UL>
    <LI>
        <B>"sizex"</B> and <B>"sizey"</B> describe the size of a contact cut.
    </LI>
    <LI>
        <B>"sep1d"</B> describes the separation between contact cuts in a one-dimensional array.
    </LI>
    <LI>
        <B>"sep2d"</B> describes the separation between contact cuts in a two-dimensional array.
    </LI>
    </UL>
    The centers of contact cuts are constrained to be in the box defined by the &lt;lambdaBox&gt; subelement
    and multicutbox's attributes "klx", "khx", "kly", and "khy".
    The NodeLayer of a "Via1" layer on a standard size node will generate a single contact cut of size 2x2 with
    the center in origin.
    When the n.extendX &ge; 2.5 [(2.0 + 3.0)/2] or n.extendY &ge; 2.5 then the NodeLayer will generate
    more contact cuts.<BR>
    Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Via1" style="FILLED"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;multicutbox sizex="2.0" sizey="2.0" sep1d="3.0" sep2d="3.0"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="0.0" khx="0.0" kly="0.0" khy="0.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/multicutbox&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;</FONT></CODE>
</LI>
<LI>
    <B>&lt;serpbox&gt;</B> a box used in serpentine transistors.
    A serpentine transistor consists of many segments of the transistor gate.
    Each segment is described when viewed from one end of the segment to the other end.
    Thus, going to the left or right indicates how far from the centerline of the segment the geometry extends.
    Going top or bottom indicates how far past the end of the segment the geometry extends.
    So, in addition to the attributes found in the &lt;box&gt; element, it has these additional attributes:
    <UL>
    <LI>
        <B>"lWidth"</B> the distance from the centerline to the "left" edge.
    </LI>
    <LI>
        <B>"rWidth"</B> the distance from the centerline to the "right" edge.
    </LI>
    <LI>
        <B>"tExtent"</B> the extension beyond the "top" point of the centerline.
    </LI>
    <LI>
        <B>"bExtent"</B> the extension beyond the "bottom" point of the centerline.
    </LI>
    </UL>
</LI>
</UL>

<P>
<!-- NEED 3in -->
When there are multiple primitive nodes that are similar,
a &lt;primitiveNodeGroup&gt; can be used to define them.
A &lt;primitiveNodeGroup&gt; has &lt;primitiveNode&gt; subelements that define the
variations among the primitives in the group.
Individual nodes in a &lt;primitiveNodeGroup&gt; can differ from each other only by name, function,
some flags, and their node layers.
Specifically:
<OL>
<LI>The &lt;name&gt; and &lt;fun&gt; attributes are moved from the &lt;primitiveNodeGroup&gt; element and
appear inside the &lt;primitiveNode&gt; subelements.</LI>
<LI>The &lt;oldName&gt;, &lt;lowVt&gt;, &lt;highVt&gt;, &lt;nativeBit&gt;, &lt;od18&gt;, &lt;od25&gt;, and &lt;od33&gt; subelements
are also moved into the &lt;primitiveNode&gt; subelements.</LI>
<LI>The &lt;nodeLayer&gt; elements inside of a &lt;primitiveNodeGroup&gt; may have an optional &lt;inNodes&gt; subelement.
This subelement defines a list of primitive nodes in the group where this &lt;nodeLayer&gt; can occur.</LI>
</OL>
Example:<BR>
    <CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;primitiveNodeGroup&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;primitiveNode name="P-Transistor" fun="TRAPMOS"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;primitiveNode name="Thick-P-Transistor" fun="TRAPMOSHV1"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;od18/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/primitiveNode&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodeBase&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box&gt;&lt;lambdaBox klx="-1.5" khx="1.5" kly="-1.0" khy="1.0"/&gt;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/nodeBase&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="P-Active" style="FILLED" portNum="1" electrical="true"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;serpbox kly="1" lWidth="4" rWidth="0" tExtent="0" bExtent="0"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-1.5" khx="1.5" kly="1" khy="4"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/serpbox&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;nodeLayer layer="Thick-Active" style="FILLED" portNum="-1"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;inNodes&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;primitiveNode name="Thick-P-Transistor"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/inNodes&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;serpbox lWidth="8.0" rWidth="8.0" tExtent="4.0" bExtent="4.0"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-5.5" khx="5.5" kly="-8.0" khy="8.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/serpbox&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/nodeLayer&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;primitivePort name="poly-left"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portAngle primary="180" range="90"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portTopology&gt;0&lt;/portTopology&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;box khx="-1.0"&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;lambdaBox klx="-3.5" khx="-3.5" kly="0.0" khy="0.0"/&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/box&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;portArc&gt;Polysilicon-1&lt;/portArc&gt;<BR>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/primitivePort&gt;<BR>
    &nbsp;&nbsp;&nbsp;&lt;/primitiveNodeGroup&gt;
</FONT></CODE>
<P>
<H4>Foundry</H4>
<P>
The Foundry section has design rules and GDS layers.
The section is usually found at the end of the XML file.
This section starts with:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;Foundry name="<I>foundryname</I>"&gt;</FONT></CODE><BR>
where <I>foundryname</I> is the name of the integrated-circuit manufacturer whose rules are enclosed.
The section ends with <CODE><FONT SIZE="-1">&lt;/Foundry&gt;</FONT></CODE>.
<P>
<!-- NEED 3in -->
Each rule in the section has some common attributes:
<UL>
<LI><B>ruleName</B> gives the name of the rule, used when printing error messages.</LI>
<LI><B>when</B> tells when the rule applies.
Most rules apply all the time, in which case the attribute has the value <CODE>ALL</CODE>.
If a rule only applies in certain states of the technology, then the <CODE>when</CODE> field will limit its use.
For example, the "mocmos" technology has Deep rules which are triggered by <CODE>when="DE"</CODE>.</LI>
<TABLE><TR><TD>
<LI><B>type</B> tells what kind of rule is being described.
The choices vary with the different rule formats.</LI>
<LI><B>value</B> tells the value of the rule, which varies with the type of the rule.
If two numbers are given, they are X and Y values for asymetric rules.</LI>
<LI><B>maxW</B> and <B>minLen</B> control the use of spacing rules in the presence of long and wide wires.
If <CODE>maxW</CODE> is given, then at least one of the pieces of geometry must be that wide.
If <CODE>minLen</CODE> is given, then the length of the common parallel run must be at least that long.</LI>
</TD><TD><CENTER><IMG SRC="fig08-06.png" ALT="Figure 8.6"></CENTER></TD></TR></TABLE>
</UL>
Here are the possible rules:
<UL>
<LI><B>LayerRule</B> is a rule for one or more layers.
In addition to the standard attributes, this rule has one or more layer names to which it applies.
The type of information can be
MINWID (minimum width of the layer),
MINAREA (the minimum area of the layer),
MINENCLOSEDAREA (the minimum area of any hold in a polygon),
SURROUND (minimum extension of a layer beyond another),
DIAGONALVIA (diagonal via rules), or
G0CPL (G0 rules).
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;LayerRule ruleName="1.1 Mosis" layerName="{P-Well, N-Well}" when="ALL"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type="MINWID" value="12.0"/&gt;</FONT></CODE><BR>
</LI>
<LI><B>LayersRule</B> is a rule for the interaction of two different layers.
In addition to the standard attributes, it has the names of the two layers.
The type of information can be
CONSPA (minimum spacing of two connected layers),
UCONSPA (minimum spacing of two unconnected layers),
SPACING (minimum spacing in both connected and unconnected situations),
UCONSPA2D (minimum spacing of a two-dimensional array of contact cuts),
FORBIDDEN (disallowed combination of layers anywhere in the design),
EXTENSION (minimum overlap of a layer extended from another),
SURROUND (minimum extension of a layer beyond another),
DIAGONALVIA (diagonal via rules), or
G0CPL (G0 rules).

Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;LayersRule ruleName="15.4 Mosis" layerNames="{Metal-3,Metal-3}"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when="ALL" type="SPACING" value="6" maxW="100" minLen="0"/&gt;</FONT></CODE><BR>
</LI>
<LI><B>NodeRule</B> gives rules for Electric nodes.
In addition to the standard attributes, it has a node name.
The type of information can be
NODSIZ (the minimum size of a node),
or
FORBIDDEN (the node is not allowed).
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;NodeRule ruleName="5.2 Mosis" nodeName="Metal-1-Polysilicon-1-Con"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;when="ALL" type="NODSIZ" value="5"/&gt;</FONT></CODE><BR>
</LI>
<LI><B>NodeLayersRule</B> gives rules for specific layers in a single node.
In addition to the standard attributes, it has both layer names and a node name.
The type of information can be
SURROUND (for layers in a node)
or
ASURROUND (for layers in an arc).
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;NodeLayersRule ruleName="2.3 Mosis" layerNames="{P-Well, N-Active}"<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodeName="N-Transistor" when="ALL" type="SURROUND" value="5"/&gt;</FONT></CODE><BR>
</LI>
</UL>
In addition to design-rules, the GDS layer assignments are also found in the Foundry section.
Each GDS layer line has this format:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;layerGds layer="XXXX" gds="YYYY"/&gt;</FONT></CODE><BR>
Where XXXX is the layer name and YYYY is the GDS information for that layer.
The GDS information can include multiple layer numbers, for example "21,49,98".
GDS layers can have type information if separated by a slash, for example layer 14 type 141 is "21/141".
GDS layers can be used for Pins (export locations) and Text (export names) by appending a "p" or "t" to the layer number,
for example "21,49p,74/2t".
Example:<BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;layerGds layer="Metal-1" gds="49,80p,80t"/&gt;</FONT></CODE><BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;layerGds layer="Metal-2" gds="41/40,141p"/&gt;</FONT></CODE><BR>
<CODE><FONT SIZE="-1">&nbsp;&nbsp;&nbsp;&lt;layerGds layer="Metal-3" gds="98"/&gt;</FONT></CODE><BR>
Defines Metal-1 to be on GDS layer 49, or 80 for pins or text; defines Metal-2 to be on GDS layer 41, type 40 or on layer 141 for pins;
and defines Metal-3 to be on GDS layer 98.
<!-- TRAILER -->
